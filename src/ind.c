/**
 * @file
 * @brief vu-meter
 * @details Программа управления светодиодным индикатором уровня стереосигнала
 * для устройства http://hawelson.blog.cz/1005/vu-metr-2x32led-s-mikrokontrolerem
 *
 * MCU: ATmega8, ATmega8L на частоте 1 МГц.
 *
 * @version 2
 * @date 7-8.09.2011 исправление ошибок режима "зеркально".
 * @date 27.08.2011 Добавлена опция компиляции "зеркально" для альтернативного
 *      варианта печатной платы (#define MIRROR).
 * @date 16.08.2011 Возможность выбора режима отображения работающего устройства.
 * @date 11.08.2011 Отображение текущего уровня точкой место линии.
 * @date 8-10.08.2011 Отображение текущего значения в виде линии, пикового -
 *      точкой. Возможность выбора линейной или логарифмической шкалы при
 *      компиляции (#define LOGARIFM).
 * @author Nick Egorrov
 * @copyright Copyright 2011 Nick Egorrov
 * @copyright http://www.apache.org/licenses/LICENSE-2.0
 */

/************************************//*
 * Назначение выводов для линейки
 * светодиодов.
 PC2
 PC3
 PC4
 PC5
 PD0
 PD1
 PD2
 PD3
 PD4
 PB6
 PB7
 PD5
 PD6
 PD7
 PB0
 PB1
 * Выводы управления секциями
 PB2 - правая чётная
 PB3 - правая нечётная
 PB4 - левая  чётная
 PB5 - левая  нечётная
 ***************************************/

#include <avr/io.h>
#include <util/delay.h>

#define LOOP_DELAY  1500

typedef unsigned char BYTE;
typedef unsigned int WORD;

/* Константы для АЦП
 ***************************************/
#define ADC_MODE    0b10000000
#define ADC_START   0b01000000
#define ADC_FINISH  0b00010000
/* Выбор предделителя частоты АЦП */
/*#define ADC_SCALER  0b00000001   :2   */
/*#define ADC_SCALER  0b00000010   :4   */
#define ADC_SCALER  0b00000011  /* :8   */
/*#define ADC_SCALER  0b00000100   :16  */
/*#define ADC_SCALER  0b00000101   :32  */
/*#define ADC_SCALER  0b00000110   :64  */
/*#define ADC_SCALER  0b00000111   :128 */

/* Задержки индикации
 * Tзадержки=2*(время цикла)*(X+1)
 ***************************************/
#define LINE_DELAY  7   /* 5 Задержка для скатывания линии */
#define DOT_DELAY   14  /* 11 Задержка для скатывания пика */
#define DOT_HOLD    199 /* "Зависание" пика */

/* Режимы работы
 ***************************************/
#define MODE_PEAK       0b00000001
#define MODE_LINE       0b00000010
#define MODE_LINEAR     0b00000100

void UpdateMode(void);
void Show(BYTE bCanel);
void UpdateLevel(WORD wADC, BYTE bCanel);

/* Глобальные переменные
 ***************************************/
BYTE bMode; /* Режим работы устройства */
BYTE bLine[2] = {
}; /* Текущее значение для каналов */
BYTE bDot[2] = {
}; /* Пиковое значение для каналов */
BYTE bCountLine[2] = {
};
BYTE bCountDot[2] = {
};

/* Зависимости для преобразования
 * результата АЦП
 ***************************************/
#define FIRST_STEP 8    /* Смещение начала линейной шкалы */

/* Массив для нелинейного преобразования
 ***************************************/
#ifndef SERGEY
/* Логарифмическая зависимость шаг 0.75 dB */
WORD tLog[] = {
                4, 5, 6, 7, 9, 11, 13, 15, 18, 21, 25, 30, 35, 42, 50, 59, 70,
                84, 99, 118, 141, 167, 199, 236, 280, 333, 396, 471, 559, 665,
                790, 939, 1023
};
#else
/* Вариант Сергея Михайлова */
WORD tLog[]= {
        8, 9, 12, 17, 24, 33, 44, 57,
        72, 89, 108, 129, 152, 177, 204, 233,
        264, 297, 332, 369, 408, 449, 492, 537,
        584, 633, 684, 737, 792, 849, 906, 963,
        1023};
#endif

/***************************************************************
 * Секция настройки для различных вариантов подключения        *
 * светодиодов, ключей и прочего.                              *
 *   CLASSIC - оригинальная схема и расположение светодиодов,  *
 *     как это описано на сайтах                               *
 *   MIRROR  - альтернативная разводка, при которой линейки    *
 *     сведодиодов расположены не в два ряда, а в один, при    *
 *     этом светодиодв расположены так                         *
 *       L1 L2 L3.....L29 L31 L32  R32 R31 R30.....R3 R2 R1    *
 *   ARRAY - схема и разводка для двух рядов из шкальных       *
 *     светодиодов и МК в корпусе TQFP
 ***************************************************************/

#ifdef CLASSIC
/* Массив управления светодиодами */
BYTE tIndik[]= {
        0b00000000, 0b00000000, 0b00000000,
        0b00000000, 0b00000000, 0b00000000, /* =0 */
        0b00000010, 0b00000000, 0b00000000, /* =1 */
        0b00000011, 0b00000000, 0b00000000,
        0b00000011, 0b00000000, 0b10000000,
        0b00000011, 0b00000000, 0b11000000,
        0b00000011, 0b00000000, 0b11100000,
        0b10000011, 0b00000000, 0b11100000,
        0b11000011, 0b00000000, 0b11100000,
        0b11000011, 0b00000000, 0b11110000,
        0b11000011, 0b00000000, 0b11111000,
        0b11000011, 0b00000000, 0b11111100,
        0b11000011, 0b00000000, 0b11111110,
        0b11000011, 0b00000000, 0b11111111,
        0b11000011, 0b00100000, 0b11111111,
        0b11000011, 0b00110000, 0b11111111,
        0b11000011, 0b00111000, 0b11111111,
        0b11000011, 0b00111100, 0b11111111 /* =16 */
};

#define ADC_CANAL_LEFT  0
#define ADC_CANAL_RIGHT 1

/* Маски разрядов портов, используемых для светодиодов */
#define LED_MASK_B 0b11000011
#define LED_MASK_C 0b00111100
#define LED_MASK_D 0b11111111

/* Маски разрядов портов, используемых для управления ключами */
#define KEY_MASK_B 0b00111100
#define KEY_MASK_C 0b00000000
#define KEY_MASK_D 0b00000000

/* Макросы управления ключами */
#define _switch_left_bottom()  {PORTB|=0b00000100;}
#define _switch_left_top()     {PORTB|=0b00001000;}
#define _switch_right_bottom() {PORTB|=0b00010000;}
#define _switch_right_top()    {PORTB|=0b00100000;}

/*
 * Макросы для опроса состояния перемычек.
 * PD4=1 - отображение пикового уровня.
 * PD5=1 - текущий уровень в виде линии,
 *         иначе - в виде точки.
 * PB7=1 - линейное преобразование АЦП.
 * Состоянию "1" соответствует отсутствие перемычки.
 */
#define _is_key_peek()   ((PIND & 0b00000001) != 0)
#define _is_key_line()   ((PIND & 0b00100000) != 0)
#define _is_key_linear() ((PINB & 0b10000000) != 0)

#elif defined MIRROR

BYTE tIndik[]= {
        0b00000000, 0b00000000, 0b00000000,
        0b00000000, 0b00000000, 0b00000000, /* =0 */
        0b00000010, 0b00000000, 0b00000000, /* =1 */
        0b00000011, 0b00000000, 0b00000000,
        0b00000011, 0b00000000, 0b10000000,
        0b00000011, 0b00000000, 0b11000000,
        0b00000011, 0b00000000, 0b11100000,
        0b10000011, 0b00000000, 0b11100000,
        0b11000011, 0b00000000, 0b11100000,
        0b11000011, 0b00000000, 0b11110000,
        0b11000011, 0b00000000, 0b11111000,
        0b11000011, 0b00000000, 0b11111100,
        0b11000011, 0b00000000, 0b11111110,
        0b11000011, 0b00000000, 0b11111111,
        0b11000011, 0b00100000, 0b11111111,
        0b11000011, 0b00110000, 0b11111111,
        0b11000011, 0b00111000, 0b11111111,
        0b11000011, 0b00111100, 0b11111111 /* =16 */
        /*  */
        ,0b00000000, 0b00000000, 0b00000000,
        0b00000000, 0b00000000, 0b00000000, /* =0 */
        0b00000000, 0b00000100, 0b00000000, /* =1 */
        0b00000000, 0b00001100, 0b00000000,
        0b00000000, 0b00011100, 0b00000000,
        0b00000000, 0b00111100, 0b00000000,
        0b00000000, 0b00111100, 0b00000001,
        0b00000000, 0b00111100, 0b00000011,
        0b00000000, 0b00111100, 0b00000111,
        0b00000000, 0b00111100, 0b00001111,
        0b00000000, 0b00111100, 0b00011111,
        0b01000000, 0b00111100, 0b00011111,
        0b11000000, 0b00111100, 0b00011111,
        0b11000000, 0b00111100, 0b00111111,
        0b11000000, 0b00111100, 0b01111111,
        0b11000000, 0b00111100, 0b11111111,
        0b11000001, 0b00111100, 0b11111111,
        0b11000011, 0b00111100, 0b11111111 /* =16 */
};

#define ADC_CANAL_LEFT  0
#define ADC_CANAL_RIGHT 1

/* Маски разрядов портов, используемых для светодиодов */
#define LED_MASK_B 0b11000011
#define LED_MASK_C 0b00111100
#define LED_MASK_D 0b11111111

/* Маски разрядов портов, используемых для управления ключами */
#define KEY_MASK_B 0b00111100
#define KEY_MASK_C 0b00000000
#define KEY_MASK_D 0b00000000

/* Макросы управления ключами */
#define _switch_left_bottom()  {PORTB|=0b00000100;}
#define _switch_left_top()     {PORTB|=0b00001000;}
#define _switch_right_bottom() {PORTB|=0b00010000;}
#define _switch_right_top()    {PORTB|=0b00100000;}

/*
 * Макросы для опроса состояния перемычек.
 * PD4=1 - отображение пикового уровня.
 * PD5=1 - текущий уровень в виде линии,
 *         иначе - в виде точки.
 * PB7=1 - линейное преобразование АЦП.
 * Состоянию "1" соответствует отсутствие перемычки.
 */
#define _is_key_peek()   ((PIND & 0b00000001) != 0)
#define _is_key_line()   ((PIND & 0b00100000) != 0)
#define _is_key_linear() ((PINB & 0b10000000) != 0)

#elif defined ARRAY

BYTE tIndik[]= {
        0b00000000, 0b00000000, 0b00000000,
        0b00000000, 0b00000000, 0b00000000, /* =0 */
        0b00000000, 0b00000000, 0b00000001, /* =1 */
        0b00000000, 0b00100000, 0b00000001,
        0b00000000, 0b00110000, 0b00000001,
        0b00000000, 0b00111000, 0b00000001,
        0b00000000, 0b00111100, 0b00000001,
        0b00000000, 0b00111100, 0b00000011,
        0b00000000, 0b00111100, 0b00000111,
        0b00000000, 0b00111100, 0b00001111,
        0b00000000, 0b00111100, 0b00011111,
        0b01000000, 0b00111100, 0b00011111,
        0b11000000, 0b00111100, 0b00011111,
        0b11000000, 0b00111100, 0b00111111,
        0b11000000, 0b00111100, 0b01111111,
        0b11000000, 0b00111100, 0b11111111,
        0b11000001, 0b00111100, 0b11111111,
        0b11000011, 0b00111100, 0b11111111 /* =16 */
};

#define ADC_CANAL_LEFT  6
#define ADC_CANAL_RIGHT 7

/* Маски разрядов портов, используемых для светодиодов */
#define LED_MASK_B 0b11000011
#define LED_MASK_C 0b00111100
#define LED_MASK_D 0b11111111

/* Маски разрядов портов, используемых для управления ключами */
#define KEY_MASK_B 0b00011000
#define KEY_MASK_C 0b00000011
#define KEY_MASK_D 0b00000000

/* Макросы управления ключами */
#define _switch_left_bottom()  {PORTB|=0b00010000;}
#define _switch_left_top()     {PORTB|=0b00001000;}
#define _switch_right_bottom() {PORTC|=0b00000001;}
#define _switch_right_top()    {PORTC|=0b00000010;}

/*
 * Макросы для опроса состояния перемычек.
 * PD1=1 - отображение пикового уровня.
 * PC2=1 - текущий уровень в виде линии,
 *         иначе - в виде точки.
 * PC3=1 - линейное преобразование АЦП.
 * Состоянию "1" соответствует отсутствие перемычки.
 */
#define _is_key_peek()   ((PIND & 0b00000010) != 0)
#define _is_key_line()   ((PINC & 0b00000100) != 0)
#define _is_key_linear() ((PINC & 0b00001000) != 0)

#else
/* Неизвестная конфигурация. */
#error unknown target
#endif

/*************************************
 * Запуск микроконтоллёра.
 *************************************/
int main()
{
        BYTE bCount = 0; /* Счётчик для динамической индикации */
        BYTE bCanel;

        /* Инициализация портов для индикации происходит при
         * вызове функции UpdateMode. */
        DDRB |= KEY_MASK_B;
        DDRC |= KEY_MASK_C;
        DDRD |= KEY_MASK_D;

        while (1) {
                if (!bCount) {
                        UpdateMode();
                }

                bCanel = bCount & 0x01;

                /* Подготовка к запуску АЦП, выбор канала */
                if (!bCanel) {
                        ADMUX = 0b11000000 | ADC_CANAL_LEFT;
                } else {
                        ADMUX = 0b11000000 | ADC_CANAL_RIGHT;
                }

                Show(bCount);

                /* Запуск АЦП и задержка */
                ADCSRA = ADC_MODE | ADC_SCALER | ADC_START;
                _delay_us(LOOP_DELAY);
                while (!(ADCSRA & ADC_FINISH))
                        ;

                /* Преобразование результата АЦП */
                UpdateLevel(ADC, bCanel);

                /* Сброс флага прерывания АЦП */
                ADCSRA = ADC_MODE | ADC_SCALER | ADC_FINISH;

                bCount++;
        }
}

/***********************************************
 * Функция опроса состояния перемычек
 * и обновления режима индикации.
 ***********************************************/
void UpdateMode(void)
{
        /* Гасим индикатор и переводим
         * порты в режим ввода
         ***********************************/
        PORTB = 0;
        PORTC = 0;
        PORTD = 0;
        _delay_us(25);

        PORTB = LED_MASK_B;
        PORTC = LED_MASK_C;
        PORTD = LED_MASK_D;

        DDRB &= ~LED_MASK_B;
        DDRC &= ~LED_MASK_C;
        DDRD &= ~LED_MASK_D;

        bMode = 0;

        if (_is_key_peek()) {
                bMode |= MODE_PEAK;     // Пик
        }

        if (_is_key_line()) {
                bMode |= MODE_LINE;     // Линия
        }

        if (_is_key_linear()) {
                bMode |= MODE_LINEAR;   // Линейно
        }

        PORTB = 0;
        PORTC = 0;
        PORTD = 0;

        DDRB |= LED_MASK_B;
        DDRC |= LED_MASK_C;
        DDRD |= LED_MASK_D;
        return;
}

void Show(BYTE bCount)
{
        BYTE bPortB, bPortC, bPortD;
        BYTE l, p;

        /* Гасим индикатор и
         * немного ждём.
         ***********************************/
        PORTB = 0;
        PORTC = 0;
        PORTD = 0;
        bPortB = 0;
        bPortC = 0;
        bPortD = 0;
        _delay_us(25);

        /* Выбор индицируемой части индикатора
         * и, соответственно, открытого
         * транзистора
         ***********************************/
        switch (bCount & 0x03) {
        case 0:
                _switch_left_bottom();
                break;
        case 1:
                _switch_left_top();
                break;
        case 2:
                _switch_right_bottom();
                break;
        case 3:
                _switch_right_top();
                break;
        }

        /* Получение индексов для
         * нужного канала.
         ***********************************/
        if (bCount & 0x02) {
                l = bLine[1];
                p = bDot[1];
        } else {
                l = bLine[0];
                p = bDot[0];
        }

        /* Коррекция индексов в зависимости
         * от индицируемой половины шкалы и
         * от режима индикации.
         ***********************************/
        if (bCount & 0x01) {
                if ((l & 0x01) && !(bMode & MODE_LINE)) {
                        l = 2;
                } else {
                        l = l + 2;
                }

                if (p & 0x01) {
                        p = 2;
                } else {
                        p = p + 2;
                }
        } else {
                if (!(l & 0x01) && !(bMode & MODE_LINE)) {
                        l = 2;
                } else {
                        l = l + 3;
                }

                if (p & 0x01) {
                        p = p + 3;
                } else {
                        p = 2;
                }
        };

        /* Умножение индексов на 1.5 .
         * Получаем индекс в диапазоне
         * от 3 до 51 с шагом 3
         ***********************************/
        l = l & 0xfe;
        l = l + (l >> 1);
        p = p & 0xfe;
        p = p + (p >> 1);

        /* Для альтернативной платы разные
         * каналы используют разные массивы
         * управления индикацией.
         ***********************************/
#ifdef MIRROR
        if (!(bCount & 0x02)) {
                l=l+54;
                p=p+54;
        }
#endif

        if (bMode & MODE_LINE) {
                bPortB = bPortB | tIndik[l];
                bPortC = bPortC | tIndik[l + 1];
                bPortD = bPortD | tIndik[l + 2];
        } else {
                bPortB = bPortB | (tIndik[l] & (~tIndik[l - 3]));
                bPortC = bPortC | (tIndik[l + 1] & (~tIndik[l - 2]));
                bPortD = bPortD | (tIndik[l + 2] & (~tIndik[l - 1]));
        }

        if (bMode & MODE_PEAK) {
                bPortB = bPortB | (tIndik[p] & (~tIndik[p - 3]));
                bPortC = bPortC | (tIndik[p + 1] & (~tIndik[p - 2]));
                bPortD = bPortD | (tIndik[p + 2] & (~tIndik[p - 1]));
        }

        PORTC |= bPortC;
        PORTD |= bPortD;
        PORTB |= bPortB;
        return;
}

/* Функция преобразования результата АЦП
 * и обновления текущего и пикового
 * уровня соответствующего канала.
 **************************************/
void UpdateLevel(WORD wADC, BYTE bCanel)
{
        BYTE bLevel;

        /* Преобразование результата АЦП */
        if (bMode & MODE_LINEAR) bLevel = (wADC + (32 - FIRST_STEP)) >> 5;
        else {
                for (bLevel = 0; bLevel <= 32; bLevel++) {
                        if (tLog[bLevel] >= wADC) break;
                }
        }

        /* Обновление текущего значения */
        if (bLevel >= bLine[bCanel]) {
                bLine[bCanel] = bLevel;
                bCountLine[bCanel] = LINE_DELAY;
        } else {
                if (bCountLine[bCanel]) bCountLine[bCanel]--;
                else {
                        bLine[bCanel]--;
                        bCountLine[bCanel] = LINE_DELAY;
                }
        }

        /* Обновление пикового уровня */
        if (bLine[bCanel] > bDot[bCanel]) {
                bDot[bCanel] = bLine[bCanel];
                bCountDot[bCanel] = DOT_HOLD;
        } else {
                if (bCountDot[bCanel]) bCountDot[bCanel]--;
                else {
                        bCountDot[bCanel] = DOT_DELAY;
                        if (bDot[bCanel]) bDot[bCanel]--;
                }
        }
}
